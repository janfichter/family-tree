// family-chart.min.js - v0.0.0-beta-1 (modified)
// Copyright 2021 Donat Soric
(function () {
    function createStore(data) {
        const store = {
            state: {
                data: data.data || [],
                main_id: data.main_id || null,
                node_separation: data.node_separation || 250,
                level_separation: data.level_separation || 150,
                tree: []
            },
            update: {
                mainId(id) {
                    this.state.main_id = id;
                },
                tree(config) {
                    this.state.tree = calculateTree(this.state);
                    if (config && config.initial) {
                        this.tree = this.state.tree;
                    }
                }
            },
            getData() {
                return this.state.data;
            },
            getTree() {
                return this.state.tree;
            }
        };

        return store;
    }

    function d3AnimationView({ store, cont }) {
        const svg = d3.select(cont).append("svg")
            .attr("width", "100%")
            .attr("height", "100%");
        
        const g = svg.append("g");

        return {
            svg: g,
            update(config) {
                g.selectAll("*").remove();
                // Здесь будет отрисовка дерева на основе store.getTree()
            }
        };
    }

    function createCard({ store, svg, card_dim, card_display }) {
        const template = `
            <g class="card">
                <rect width="${card_dim.w}" height="${card_dim.h}" rx="5" ry="5" fill="#fff" stroke="#999" />
                <text x="${card_dim.text_x}" y="${card_dim.text_y}">
                    ${card_display.map(d => `<tspan dy="14">${d(store.state.data[0])}</tspan>`).join('')}
                </text>
            </g>
        `;

        const card = {
            template: template,
            mounted(el) {
                el.innerHTML = template;
            }
        };

        return card;
    }

    function calculateTree(state) {
        const nodes = state.data;
        const main_id = state.main_id;

        const idToNodeMap = Object.fromEntries(nodes.map(n => [n.id, n]));

        const tree = [];
        const visited = new Set();

        function buildTree(node, depth = 0) {
            if (visited.has(node.id)) return;
            visited.add(node.id);

            const children = (node.rels?.children || [])
                .map(id => idToNodeMap[id])
                .filter(Boolean);

            tree.push({
                ...node,
                depth: depth,
                x: 0,
                y: 0
            });

            children.forEach(child => {
                buildTree(child, depth + 1);
            });
        }

        if (main_id && idToNodeMap[main_id]) {
            buildTree(idToNodeMap[main_id]);
        } else if (nodes.length > 0) {
            buildTree(nodes[0]);
        }

        return tree;
    }

    window.f3 = {
        createStore,
        d3AnimationView,
        elements: {
            Card: createCard
        },
        CalculateTree: calculateTree
    };
})();