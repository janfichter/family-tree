(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined'
        ? (module.exports = factory(require('d3')))
        : typeof define === 'function' && define.amd
            ? define(['d3'], factory)
            : ((global = typeof globalThis !== 'undefined' ? globalThis : global),
              (global.f3 = factory(global.d3)));
})(this, function(d3) {
    'use strict';

    function createStore(data) {
        const state = {
            data: data.data || [],
            main_id: data.main_id || null,
            node_separation: data.node_separation || 250,
            level_separation: data.level_separation || 150,
            tree: []
        };

        console.log("store created:", state);

        function calculateTree() {
            const nodesMap = {};
            state.data.forEach(d => {
                if (!d.id) return;
                nodesMap[d.id] = d;
            });

            console.log("nodesMap:", nodesMap);

            const tree = [];

            function buildDown(person, depth = 0) {
                if (tree.some(n => n.id === person.id)) return;

                const node = { ...person, depth };
                tree.push(node);

                if (person.rels?.children) {
                    person.rels.children.forEach(id => {
                        const child = nodesMap[id];
                        if (child) buildDown(child, depth + 1);
                    });
                }
            }

            function buildUp(person, depth = 0) {
                if (tree.some(n => n.id === person.id)) return;

                const node = { ...person, depth };
                tree.unshift(node); // добавляем в начало дерева

                const parents = [];
                if (person.rels?.father) parents.push(person.rels.father);
                if (person.rels?.mother) parents.push(person.rels.mother);

                parents.forEach(id => {
                    const parent = nodesMap[id];
                    if (parent) buildUp(parent, depth - 1);
                });
            }

            if (state.main_id && nodesMap[state.main_id]) {
                buildDown(nodesMap[state.main_id], 0);
                buildUp(nodesMap[state.main_id], 0);
            } else if (state.data.length > 0) {
                buildDown(state.data[0], 0);
                buildUp(state.data[0], 0);
            }

            // Проставляем координаты
            const positionedTree = tree.map((node, index) => ({
                ...node,
                _x: node.depth * state.node_separation,
                _y: index * state.level_separation
            }));

            state.tree = positionedTree;
            console.log("calculateTree(): Обновили store.state.tree", state.tree);
        }

        return {
            state: state,
            update: {
                mainId(id) {
                    this.state.main_id = id;
                    calculateTree();
                },
                tree(config) {
                    calculateTree();
                    if (config && config.initial) {
                        this.tree = this.state.tree;
                    }
                }
            },
            getData() {
                return this.state.data;
            },
            getTree() {
                return this.state.tree;
            },
            setOnUpdate(fn) {}
        };
    }

    function d3AnimationView({ store, cont, card_dim, card_display }) {
        const svg = d3.select(cont).append("svg")
            .attr("width", "100%")
            .attr("height", "100%");
        const g = svg.append("g");

        function drawCard(node) {
            if (!node._x || !node._y) {
                console.warn("Карточка без координат", node);
                return;
            }

            const card = g.append("g")
                .attr("class", "card")
                .attr("transform", `translate(${node._x}, ${node._y})`);

            card.append("rect")
                .attr("width", card_dim.w)
                .attr("height", card_dim.h)
                .attr("fill", "#fff")
                .attr("stroke", "#999");

            card.append("text")
                .attr("x", card_dim.text_x)
                .attr("y", card_dim.text_y)
                .text(card_display[0](node));

            for (let i = 1; i < card_display.length; i++) {
                card.append("text")
                    .attr("x", card_dim.text_x)
                    .attr("y", card_dim.text_y + i * 15)
                    .text(card_display[i](node));
            }
        }

        return {
            svg: g,
            update(props) {
                g.selectAll("*").remove();

                if (store.getTree().length === 0) {
                    console.warn("store.tree пустой — связи могут быть некорректны");
                }

                store.getTree().forEach(drawCard);
            }
        };
    }

    function createCard({ store, svg, card_dim, card_display }) {
        return {
            template: `<g><rect width="${card_dim.w}" height="${card_dim.h}" fill="#fff" stroke="#999"/></g>`,
            mounted(el) {
                el.innerHTML = this.template;
            }
        };
    }

    const f3 = {
        createStore: createStore,
        d3AnimationView: d3AnimationView,
        elements: {
            Card: createCard
        },
        CalculateTree: function(state) {
            return state.tree;
        }
    };

    window.f3 = f3;
    return f3;
});